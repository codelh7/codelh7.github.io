[{"categories":null,"content":"个人简介： 学习经历：计算机科班 | 211本科生 | top5硕士 技能：算法竞赛小学生 | 技术爱好者 | 分布式存储入门级 工作经历： 2021年7月入职腾讯实习 联系方式： email: chaolee0830@qq.com ","date":"2021-05-20","objectID":"/about/about/:0:0","tags":null,"title":"关于我","uri":"/about/about/"},{"categories":["CMU 15-445"],"content":"任务描述 This component is responsible for tracking page usage in the buffer pool. You will implement a new sub-class called LRUReplacer in src/include/buffer/lru_replacer.h and its corresponding implementation file in src/buffer/lru_replacer.cpp. LRUReplacer extends the abstract Replacer class (src/include/buffer/replacer.h), which contains the function specifications. The size of the LRUReplacer is the same as buffer pool since it contains placeholders for all of the frames in the BufferPoolManager. However, not all the frames are considered as in the LRUReplacer. The LRUReplacer is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the LRUReplacer. You will need to implement the LRU policy discussed in the class. You will need to implement the following methods: Victim(T*) : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. Pin(T) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. Unpin(T) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. Size() : This method returns the number of frames that are currently in the LRUReplacer. The implementation details are up to you. You are allowed to use built-in STL containers. You can assume that you will not run out of memory, but you must make sure that the operations are thread-safe. 这是project 1的第一个部分，根据上面的描述，我们的任务是实现LRU替换策略。 课程为我们提供的代码已经包括了一些必要的声明，我们需要在理解$LRU$的工作原理的基础上实现上述的四个函数。 ","date":"2021-06-17","objectID":"/project1-1/:1:0","tags":["LRU","Database"],"title":"Project1—BufferPoolManager LRU替换策略","uri":"/project1-1/"},{"categories":["CMU 15-445"],"content":"LRU原理及实现 ","date":"2021-06-17","objectID":"/project1-1/:2:0","tags":["LRU","Database"],"title":"Project1—BufferPoolManager LRU替换策略","uri":"/project1-1/"},{"categories":["CMU 15-445"],"content":"LRU LRU: Least recently used。LRU是一种缓存算法，通常也叫做缓存替换策略，用来管理内存中的缓存。根据wikipedia的描述1，存在将近二十种缓存替换策略。 LRU作为其中一种替换策略，中文表述是最近最久未使用算法。 图1.LRU示意图 基本思想：因为内存是有限的，缓存区也是有限的，因此当缓存中 page 满了且我们需要载入一个新的 page 的时候，必须将缓存中的一个 page 替换出去，将需要的 page 再替换进来，才能满足我们的使用需求。为了解决上述的问题， LRU 的基本思想是，将缓存中最久未使用过的 page 替换出去。 实现LRU：根据上面的描述，我们需要维护每个 page 最近被使用的时间戳，每当我们需要从缓存中挑选一个 page 进行置换的时候，找到时间戳最小的 page 即可。 算法尝试：一个看上去比较正确的想法是，我们使用小根堆来保存每个 page 的时间戳和 page_id （在C++中可以使用pair来维护这两个信息），我们每次只需要将堆顶取出即可找到应该被移除的 page，而且时间复杂度也不高 $log(n)$。但是该算法忽略的部分是，每次我们访问缓存中存在的page 时，我们需要对该 page 的时间戳进行修改！如果我们在堆中按照时间戳来维护 page 的话，我们的修改操作时间复杂度将是$O(N)$的。如图1所示（图源自Wikipedia1），我们在访问 page D之后，需要对 D 的时间戳进行修改。 正确算法： 我们使用 双链表 + 哈希表 实现 LRU。首先，双链表用来维护所有的 page，并且按照时间戳进行维护，时间戳越小的放在双链表越靠前的位置，反之则放在双链表越靠后的位置，这样我们可以$O(1)$时间复杂度找到时间戳最小的page；然后，为了解决之前提到的需要对page进行修改的操作，我们使用哈希表维护每个page在链表中的位置，即指针，当我们要访问一个page的时候，只需要查找哈希表找到page的位置即可，每次对page进行访问之后，我们在链表中删除该page，并将该page重新添加到链表的尾部，同时更新哈希表。 当然，我们不需要自己实现双链表和哈希表，使用C++中强大的STL可以极大地简化我们的工作。STL中 std::list\u003cT\u003e实现了双链表，std::unordered_map\u003cKey,T\u003e实现了哈希表。 为了验证自己掌握了该算法，可以到leetcode 题库进行验证。 ","date":"2021-06-17","objectID":"/project1-1/:2:1","tags":["LRU","Database"],"title":"Project1—BufferPoolManager LRU替换策略","uri":"/project1-1/"},{"categories":["CMU 15-445"],"content":"代码实现 根据课程在主页上的声明，独立完成实验的编写很重要，因此这里不会将代码完整放出，只介绍部分接口实现代码。 LRU管理的是那些没有正在被内存使用的frame，为了区分磁盘上的page和缓存中管理的page，在内存中用frame来表示page。 bool Victim(frame_id_t *frame_id): 函数功能：该函数的作用是从缓存中置换一个frame出去，并将frame_id保存在参数中。 返回值：如果能够置换出一个frame，则返回true，否则返回false 实现：将list中时间戳最大的frame取出，记录该frame_id到参数中，并更新list和unordered_map if (lst_.empty()) { *frame_id = INVALID_PAGE_ID; return false; } *frame_id = lst_.back(); lst_.pop_back(); m_.erase(*frame_id); return true; void Pin(frame_id_t frame_id): 函数功能：pin表示的是我们将要固定住一个frame，接下来我们要对这个frame进行操作，那么我们在进行页面置换操作的时候，就不应该考虑该frame了，也就是将一个frame从LRU管理器中移除。 返回值：void 实现：从 unordered_map 中找到 frame_id 对应的frame，并从 list 中移除 auto iter_m = m_.find(frame_id); if (iter_m == m_.end()) { return; } auto iter_lst = m_[frame_id]; lst_.erase(iter_lst); m_.erase(iter_m); void Unpin(frame_id_t frame_id): 函数功能：Unpin一个frame表示我们对该frame的操作已经结束了，该frame在接下来的操作中可以被移除，那么把它交个 LRU 管理器进行管理。也就是将frame_id 添加到 list 和 unordered_map 中 返回值：void 实现：将 frame_id 添加到 list 中，并在 unordered_map 中添加 {frame_id, iterator_on_list}。 这里需要判断LRU能够管理的frame个数，如果超过了，则需要先从LRU中替换出一个frame，即调用 victim。 auto iter_m = m_.find(frame_id); if (iter_m != m_.end()) { return; } lst_.push_front(frame_id); m_[frame_id] = lst_.begin(); if (lst_.size() \u003e num_pages_) { frame_id_t frame_id; Victim(\u0026frame_id); } ","date":"2021-06-17","objectID":"/project1-1/:2:2","tags":["LRU","Database"],"title":"Project1—BufferPoolManager LRU替换策略","uri":"/project1-1/"},{"categories":["CMU 15-445"],"content":"总结 刷 leetcode 算法题目和实际应用中实现该算法还是有一些区别的，在这里我们不仅要考虑从 LRU 管理器中插入一个 frame 和 删除一个 frame 需要怎么实现，更多的是需要考虑什么时候会执行这些操作。 LRU在实际应用场景的作用是管理那些曾经被使用过但是现在没有被正在使用的frame，正在被使用的frame不应该被移除，没有被使用过的frame不需要被移除（因为当有新的page从磁盘读入的时候，直接获取没有被使用过的frame即可）。 在我们要对一个 frame 进行操作的时候，我们应该将该 frame 从 LRU 中进行移除，即 Pin 操作 当我们对一个 frame 操作完毕，我们应该将该 frame 交给 LRU 进行管理，当内存中没有空闲的 frame 的时候，可以将该 frame 作为候选移除 frame, 即 Unpin 操作 LRU 的空间复杂度: $O(n)$, 时间复杂度: $O(1)$ 参考： [1] Cache replacement policies 请各位看官批评指正，接受任何善意的建议 ","date":"2021-06-17","objectID":"/project1-1/:3:0","tags":["LRU","Database"],"title":"Project1—BufferPoolManager LRU替换策略","uri":"/project1-1/"},{"categories":["leetcode"],"content":"Problem A - 判断矩阵经轮转后是否一致 题解： 算法：暴力枚举 思路：将$mat$这个矩阵分别顺时针旋转 90度、180度、270度、360度，然后判断是否和 $target$ 矩阵相等，只要存在一个旋转方案相等，则返回 true, 否则返回 false。 所以我们只需要编写两个函数即可，一个函数用来旋转 $mat$ 矩阵，一个函数用来判断两个矩阵是否相同 矩阵旋转函数：我们只需要枚举矩阵的左上部分旋转90、180、270、360度即可，注意矩阵长度是奇偶的情况（画图即可找到规律）。其中一个点最多能旋转出四个不同的点，用上下左右表示，可以发现四个点中上下对称，左右对称。我们知道了上面的点坐标$(x,y)$就容易写出下面的点的坐标$(n-1-x, n-1-y)$，同理于左右两点。假设第一个点是$(x,y)$, 关键得到第二个点就可以推出其他的两个点了，第二个点可以简单画图得出规律 $(y, n - 1 - x)$。 矩阵比较函数：这个函数其实可以不用写，vector重载了 operator== ，所以可以直接用 $mat==target$来判断矩阵是否相同。当然也可以写一个两重循环进行判断 int n, m; class Solution { public: void rotate(vector\u003cvector\u003cint\u003e\u003e\u0026 mat){ for(int i = 0; i \u003c n / 2; ++i){ for(int j = 0; j \u003c (m + 1) / 2; ++j){ int \u0026v = mat[i][j]; int x = j, y = n - 1 - i; swap(mat[x][y], v); x = n - 1 - i, y = n - 1 - j; swap(mat[x][y], v); x = n - 1 - j, y = i; swap(mat[x][y], v); } } } bool check(vector\u003cvector\u003cint\u003e\u003e\u0026 mat, vector\u003cvector\u003cint\u003e\u003e\u0026 target){ for(int i = 0; i \u003c n; ++i){ for(int j = 0; j \u003c m; ++j){ if(mat[i][j] != target[i][j]) return false; } } return true; } bool findRotation(vector\u003cvector\u003cint\u003e\u003e\u0026 mat, vector\u003cvector\u003cint\u003e\u003e\u0026 target) { n = mat.size(), m = mat[0].size(); for(int i = 0; i \u003c= 4; ++i){ // 此处可以直接写成 if(mat == target) return true; if(check(mat, target)) return true; rotate(mat); } return false; } }; 空间复杂度：$O(N^2)$ 时间复杂度：$O(N^2)$ ","date":"2021-04-29","objectID":"/leetcode-weekly-contest-244/:0:1","tags":["competitive programming"],"title":"LeetCode 第244场周赛题解","uri":"/leetcode-weekly-contest-244/"},{"categories":["leetcode"],"content":"Problem B - 使数组相等的减少操作次数 题解： 算法：枚举遍历、排序 思路：将数组从大到小排序，数组可以被看成是由一段一段连续相等的数字组成，从大到小统计数字；使用双指针可以计算出从$i$开始相等的数字的结尾部分$j$，对于当前这段数字来说，它的个数应该是$j$,因为之前的所有比它大的数字都已经通过减小操作变成了和当前这段数字相等的数。 class Solution { public: int reductionOperations(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); sort(nums.rbegin(), nums.rend()); int ans = 0; for(int i = 0; i \u003c n; ++i){ int j = i; while(j \u003c n \u0026\u0026 nums[i] == nums[j]) j += 1; if(j \u003e= n) break; ans += j; i = j - 1; } return ans; } }; 空间复杂度：$O(N)$ 时间复杂度：$O(N)$ ","date":"2021-04-29","objectID":"/leetcode-weekly-contest-244/:0:2","tags":["competitive programming"],"title":"LeetCode 第244场周赛题解","uri":"/leetcode-weekly-contest-244/"},{"categories":["leetcode"],"content":"Problem C - 使二进制字符串交替的最小反转次数 题解： 思路：字符串不管怎么操作，最终只有两种可能情况，’101010…‘ 形式的字符串和 ‘010101…‘形式的字符串。因此我们分别计算当前字符串转换成这两种字符串所需的代价即可。 计算代价函数：因为字符串s有两种操作，将开头元素append到最后，或者将反转一个字符。我们的目标是求出最小的反转代价。 第一种操作的本质是将字符串的前一段子串移动到字符串的尾部，这里使用一个常用的技巧来考虑所有的append情况，将字符串s复制一份放在字符串s的尾部，记为$S$，那么我们用一个长度为s.size()的窗口不断滑动，就等价于枚举了所有的append情况；至此，问题转换成了，如果知道了一个字符串$s^'$变成字符串$t$的最小反转代价，当将字符串$s^'$的首部元素移动到尾部,记为$s^{''}$，如何计算出$s^{''}$变成字符串$t$的最小反转代价？观察可得，当我们统计了字符串$s^'$和字符串$t$的所有对应位置相同的元素和不同的元素个数之后，当我们将$s^{'}$变换成$s^{''}$，所有本来$s^{'}$和$t$相同的位置的元素，现在都变成了不同的，而本来不同的元素，现在变成了相同（要特别处理一下头和尾元素，细节看代码）。 其中，字符串$s^'$变成字符串$t$的最小反转代价就很简单了，就是它们在相同位置下不同元素的个数。 class Solution { int ans = INT_MAX; int n; public: int minFlips(string s) { string res = s + s; n = s.size(); solve(res, '1'); solve(res, '0'); return ans; } void solve(string \u0026res, char t){ int a = 0, b = 0; int m = res.size(); char tmp = t; // 先得出第一个窗口所需的代价 for(int i = 0; i \u003c n; ++i){ if(res[i] == t) a++; else b++; t ^= 1; } t ^= 1; ans = min(ans, b); // 移动窗口 for(int l = 0, r = n; r \u003c m; ++r){ swap(a, b); // 处理尾部 if(res[r] == t) a += 1; else b += 1; // 处理头部 if(res[l] == tmp) b -= 1; else a -= 1; l += 1; ans = min(ans, b); } } }; 空间复杂度：$O(|S|)$ 时间复杂度：$O(|S|)$ ","date":"2021-04-29","objectID":"/leetcode-weekly-contest-244/:0:3","tags":["competitive programming"],"title":"LeetCode 第244场周赛题解","uri":"/leetcode-weekly-contest-244/"},{"categories":["leetcode"],"content":"Problem D - 装包裹的最小浪费时间 题解： 思路：对于困难的问题，我的常用做法是先将问题弱化，看看能不能找到解决方案，如果能的话，再看看加强之后应该做些什么变换。这个问题的弱化版本就是，我们只有一个供应商，那么问题就非常好做了，我们枚举每个物品，找到最小的大于它的箱子（这一步显然二分即可），然后累计代价即可。那么对于这个问题来说，有多个供应商，我们不能直接对箱子进枚举，转换下思路，我们是否可以每个供应商进行枚举，枚举它可以装的最大的物品。 const int MOD = 1000000007; typedef long long LL; class Solution { public: int minWastedSpace(vector\u003cint\u003e\u0026 p, vector\u003cvector\u003cint\u003e\u003e\u0026 b) { sort(p.begin(), p.end()); int n = p.size(); vector\u003cLL\u003esum(n+1); for(int i = 0; i \u003c n; ++i){ sum[i] = p[i]; if(i) sum[i] += sum[i-1]; } LL ans = 1e12; for(auto \u0026v : b){ int m = v.size(); sort(v.begin(), v.end()); if(v.back() \u003c p.back()) continue; int l = 0; LL res = 0; for(int i = 0; i \u003c m; ++i){ auto iter = upper_bound(p.begin() + l, p.end(), v[i]); if(iter == p.begin()) continue; int r = iter - p.begin() - 1; res += 1ll * (r - l + 1) * v[i]; if(l \u003e 0) res = res - sum[r] + sum[l-1]; else res = res - sum[r]; l = r + 1; } ans = min(ans, res); } if(ans == 1e12) return -1; return ans % MOD; } }; 空间复杂度：$O(N)$ 时间复杂度：$O(Nlog(N)+Mlog(N))$，其中$N$表示货物的个数，$M$表示供应商的箱子总数 请各位看官批评指正，接受任何善意的建议 ","date":"2021-04-29","objectID":"/leetcode-weekly-contest-244/:0:4","tags":["competitive programming"],"title":"LeetCode 第244场周赛题解","uri":"/leetcode-weekly-contest-244/"}]